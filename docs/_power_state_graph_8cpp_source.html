<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Disaggregate: /mnt/sshfs/imperialroot/homes/dk3810/workingcopies/disaggregate/src/PowerStateGraph.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Disaggregate</div>
   <div id="projectbrief">Disaggregate Smart Meter data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_power_state_graph_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>PowerStateGraph.cpp</h1>  </div>
</div>
<div class="contents">
<a href="_power_state_graph_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * PowerStateGraph.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Created on: 3 Aug 2011</span>
<a name="l00005"></a>00005 <span class="comment"> *      Author: jack</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;<a class="code" href="_power_state_graph_8h.html">PowerStateGraph.h</a>&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="_aggregate_data_8h.html">AggregateData.h</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;boost/graph/graphviz.hpp&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;cstdio&gt;</span> <span class="comment">// sprintf</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="keyword">using namespace </span>std;
<a name="l00016"></a>00016 
<a name="l00017"></a><a class="code" href="class_power_state_graph.html#a855e4ee7838d432e1b0a0916d3fc825d">00017</a> <a class="code" href="class_power_state_graph.html#a855e4ee7838d432e1b0a0916d3fc825d">PowerStateGraph::PowerStateGraph</a>()
<a name="l00018"></a>00018 : totalCount(0), aggData(0)
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020     <span class="keyword">using namespace </span>boost;
<a name="l00021"></a>00021 
<a name="l00022"></a>00022     <span class="comment">// add a vertex to represent &quot;off&quot;</span>
<a name="l00023"></a>00023     <span class="comment">// uses Statistic&#39;s default constructor to make a Statistic with all-zeros</span>
<a name="l00024"></a>00024     <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a> = add_vertex(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 }
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="class_power_state_graph.html#ae3eaaaca0f80786469b8674991db9476">00028</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#ae3eaaaca0f80786469b8674991db9476">PowerStateGraph::addItemToEdgeHistory</a>(
<a name="l00029"></a>00029         <span class="keyword">const</span> PSGraph::edge_descriptor&amp; edge
<a name="l00030"></a>00030         )
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032     <span class="comment">// Check if edge histories are disabled</span>
<a name="l00033"></a>00033     <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a> == 0)
<a name="l00034"></a>00034         <span class="keywordflow">return</span>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.size() &gt;= <a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a>)
<a name="l00037"></a>00037         <a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.erase( <a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.begin() );
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     <a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.push_back(edge);
<a name="l00040"></a>00040 }
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="class_power_state_graph.html#a1aff2c646dc8187249534520f8f7a4a1">00042</a> <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt; double &gt;</a>&amp; <a class="code" href="class_power_state_graph.html#a1aff2c646dc8187249534520f8f7a4a1">PowerStateGraph::getEnergyConsumption</a>()<span class="keyword"> const</span>
<a name="l00043"></a>00043 <span class="keyword"></span>{
<a name="l00044"></a>00044     <span class="keywordflow">return</span> <a class="code" href="class_power_state_graph.html#acd3ccedf90895a1c82e4b6c5b4e53300" title="Energy consumption in Joules obtained from training signatures.">energyConsumption</a>;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00050"></a><a class="code" href="class_power_state_graph.html#a90ebffe4864640182b342a814af0f0a7">00050</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a90ebffe4864640182b342a814af0f0a7" title="Update or initialise Power State Graph.">PowerStateGraph::update</a>(
<a name="l00051"></a>00051         <span class="keyword">const</span> <a class="code" href="class_signature.html" title="Class for storing a Device&amp;#39;s signature recorded by, for example, a Watts Up plug-in power logger...">Signature</a>&amp; sig,
<a name="l00052"></a>00052         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00053"></a>00053         )
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055     <span class="keyword">const</span> <span class="keywordtype">double</span> energyConsumptionFromSig = sig.<a class="code" href="class_signature.html#a8ab11925aa916b1d225dd72baba50a2c" title="Determine how many Joules of energy have been consumed.">getEnergyConsumption</a>();
<a name="l00056"></a>00056     <a class="code" href="class_power_state_graph.html#acd3ccedf90895a1c82e4b6c5b4e53300" title="Energy consumption in Joules obtained from training signatures.">energyConsumption</a>.<a class="code" href="struct_statistic.html#acabbdf2b6cc229a10a8d3d6658a0c366" title="Update an existing Statistic with new data points.">update</a>( energyConsumptionFromSig );
<a name="l00057"></a>00057     cout &lt;&lt; <span class="stringliteral">&quot;Energy consumption from sig&quot;</span> &lt;&lt; sig.<a class="code" href="class_signature.html#a901e57da453530200cd9c177295a2cd3">getID</a>() &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>
<a name="l00058"></a>00058          &lt;&lt; energyConsumptionFromSig / <a class="code" href="_common_8h.html#a8b5d4090c9b2d51d2cc9d73f481cb893" title="Joules per kWh.">J_PER_KWH</a> &lt;&lt; <span class="stringliteral">&quot; kWh&quot;</span> &lt;&lt; endl;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060     <a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.clear();
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="comment">// get the gradient spikes for the signature</span>
<a name="l00063"></a>00063     list&lt;Signature::Spike&gt; spikes = sig.<a class="code" href="class_signature.html#a02acc8e9f1ceb1af2908807eb1526fcd" title="Takes the gradient of this Signature, then merges gradient values with the same sign, then removes transient spikes, then sorts by value.">getDeltaSpikes</a>();
<a name="l00064"></a>00064     list&lt;Signature::Spike&gt;::iterator spike;
<a name="l00065"></a>00065     PSGraph::vertex_descriptor targetVertex, sourceVertex=<a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>;
<a name="l00066"></a>00066     <span class="keywordtype">size_t</span> indexOfLastAcceptedSpike = 0;
<a name="l00067"></a>00067     <span class="keywordtype">size_t</span> start=0, end=0;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="comment">// for each spike, locate the samples immediately before and immediately after the spike</span>
<a name="l00070"></a>00070     <span class="keyword">const</span> <span class="keywordtype">size_t</span> WINDOW = 8; <span class="comment">// how far either side of the spike will we look?</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     <span class="comment">// take just the top TOP_SLICE_SIZE (whilst ordered by absolute value)</span>
<a name="l00073"></a>00073     <span class="keyword">const</span> <span class="keywordtype">size_t</span> TOP_SLICE_SIZE = 10;
<a name="l00074"></a>00074     <span class="keywordflow">if</span> (spikes.size() &gt; TOP_SLICE_SIZE) {
<a name="l00075"></a>00075         list&lt;Signature::Spike&gt;::iterator it = spikes.begin();
<a name="l00076"></a>00076         advance( it, TOP_SLICE_SIZE );
<a name="l00077"></a>00077         spikes.erase( it, spikes.end() );
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080     <span class="comment">// re-order by index (i.e. by time)</span>
<a name="l00081"></a>00081     spikes.sort( <a class="code" href="struct_signature_1_1_spike.html#ad5c457fd1b72cd723bdf89f715f34abd">Signature::Spike::compareIndexAsc</a> );
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="keywordflow">for</span> (spike = spikes.begin(); spike!=spikes.end(); spike++) {
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         <span class="comment">// calculate the start index for the 8 pre-spike samples</span>
<a name="l00086"></a>00086         start = ((spike-&gt;index &gt; WINDOW) ? (spike-&gt;index - WINDOW) : 0 );
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         <span class="comment">// calculate the end index for the 8 post-spike samples</span>
<a name="l00089"></a>00089         end = spike-&gt;index + WINDOW + spike-&gt;n + 1;
<a name="l00090"></a>00090         <span class="keywordflow">if</span> (end &gt; sig.<a class="code" href="class_array.html#ae16b42080e87a53fe2b76af98995111b">getSize</a>())
<a name="l00091"></a>00091             end = sig.<a class="code" href="class_array.html#ae16b42080e87a53fe2b76af98995111b">getSize</a>();
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <span class="comment">// Create statistics for pre- and post-spike</span>
<a name="l00094"></a>00094         <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a> preSpikePowerState(sig, start, spike-&gt;index);
<a name="l00095"></a>00095         <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a> postSpikePowerState(sig, (spike-&gt;index + spike-&gt;n + 1), end);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097         <span class="comment">// check to see if spikes needs to be rejected and that the spikes aren&#39;t too close</span>
<a name="l00098"></a>00098         <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#a84bbbefd53f67b2945ac17eb11e28fdf" title="Decides whether or not to reject this spike based on the before and after statistics.">rejectSpike</a>(preSpikePowerState, postSpikePowerState) || start &lt; indexOfLastAcceptedSpike) {
<a name="l00099"></a>00099             <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot; REJECT&quot;</span>;
<a name="l00100"></a>00100         } <span class="keywordflow">else</span> {
<a name="l00101"></a>00101 
<a name="l00102"></a>00102             <span class="comment">// Create inter-spike stats</span>
<a name="l00103"></a>00103             <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a> betweenSpikesPowerState(
<a name="l00104"></a>00104                     sig,
<a name="l00105"></a>00105                     (spike-&gt;index + spike-&gt;n + 1),
<a name="l00106"></a>00106                     <a class="code" href="class_power_state_graph.html#aae4db4000f6485559f06ab4de4d54619" title="Determine the index of the next spike after spike.">indexOfNextSpike</a>( spikes, spike, sig )
<a name="l00107"></a>00107                     );
<a name="l00108"></a>00108 
<a name="l00109"></a>00109             targetVertex =
<a name="l00110"></a>00110                     <a class="code" href="class_power_state_graph.html#ac36cccb3fb0281f9b68e39ba28737770" title="Attempts to find an existing vertex which is statistically similar to stat. If an existing similar ve...">updateOrInsertVertex</a>(
<a name="l00111"></a>00111                             sig,
<a name="l00112"></a>00112                             postSpikePowerState,
<a name="l00113"></a>00113                             betweenSpikesPowerState
<a name="l00114"></a>00114                             );
<a name="l00115"></a>00115 
<a name="l00116"></a>00116             <span class="keywordflow">if</span> (sourceVertex != targetVertex) {
<a name="l00117"></a>00117                 <a class="code" href="class_power_state_graph.html#a0e3e05ae1b952132621425c042d84ec1" title="Update or Insert a new edge into powerStateGraph.">updateOrInsertEdge</a>( sourceVertex, targetVertex,
<a name="l00118"></a>00118                         (spike-&gt;index - indexOfLastAcceptedSpike), spike-&gt;delta );
<a name="l00119"></a>00119             }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121             <span class="keywordflow">if</span> (verbose)
<a name="l00122"></a>00122                 <a class="code" href="class_power_state_graph.html#a6ca3bd89b0334bdaa87c703366ffce11" title="Useful for diagnostics.">printSpikeInfo</a>( spike, start, end, preSpikePowerState, postSpikePowerState, sig);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124             sourceVertex = targetVertex;
<a name="l00125"></a>00125             indexOfLastAcceptedSpike = spike-&gt;index;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00134"></a><a class="code" href="class_power_state_graph.html#a6ca3bd89b0334bdaa87c703366ffce11">00134</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a6ca3bd89b0334bdaa87c703366ffce11" title="Useful for diagnostics.">PowerStateGraph::printSpikeInfo</a>(
<a name="l00135"></a>00135         <span class="keyword">const</span> list&lt;Signature::Spike&gt;::iterator spike,
<a name="l00136"></a>00136         <span class="keyword">const</span> <span class="keywordtype">size_t</span> start,
<a name="l00137"></a>00137         <span class="keyword">const</span> <span class="keywordtype">size_t</span> end,
<a name="l00138"></a>00138         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; preSpikePowerState,
<a name="l00139"></a>00139         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; postSpikePowerState,
<a name="l00140"></a>00140         <span class="keyword">const</span> <a class="code" href="class_signature.html" title="Class for storing a Device&amp;#39;s signature recorded by, for example, a Watts Up plug-in power logger...">Signature</a>&amp; sig
<a name="l00141"></a>00141         )<span class="keyword"> const</span>
<a name="l00142"></a>00142 <span class="keyword"></span>{
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     cout &lt;&lt; endl
<a name="l00145"></a>00145             &lt;&lt; <span class="stringliteral">&quot;SPIKE: index=&quot;</span> &lt;&lt; spike-&gt;index
<a name="l00146"></a>00146             &lt;&lt; <span class="stringliteral">&quot;, delta=&quot;</span> &lt;&lt; spike-&gt;delta
<a name="l00147"></a>00147             &lt;&lt; <span class="stringliteral">&quot;, duration=&quot;</span> &lt;&lt; spike-&gt;n
<a name="l00148"></a>00148             &lt;&lt; endl
<a name="l00149"></a>00149             &lt;&lt; <span class="stringliteral">&quot; KEEP&quot;</span> &lt;&lt; endl
<a name="l00150"></a>00150             &lt;&lt; <span class="stringliteral">&quot;Before=&quot;</span> &lt;&lt; preSpikePowerState &lt;&lt; endl
<a name="l00151"></a>00151             &lt;&lt; <span class="stringliteral">&quot;After =&quot;</span> &lt;&lt; postSpikePowerState  &lt;&lt; endl;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=start; i&lt;end; i++ ) {
<a name="l00154"></a>00154         cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; sig[i];
<a name="l00155"></a>00155         <span class="keywordflow">if</span> (i &lt; spike-&gt;index)
<a name="l00156"></a>00156             cout &lt;&lt; <span class="stringliteral">&quot; before&quot;</span>;
<a name="l00157"></a>00157         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == spike-&gt;index)
<a name="l00158"></a>00158             cout &lt;&lt; <span class="stringliteral">&quot; &lt;--SPIKE&quot;</span>;
<a name="l00159"></a>00159         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &lt; (spike-&gt;index + spike-&gt;n))
<a name="l00160"></a>00160             cout &lt;&lt; <span class="stringliteral">&quot; &lt;--Spike continues&quot;</span>;
<a name="l00161"></a>00161         <span class="keywordflow">else</span>
<a name="l00162"></a>00162             cout &lt;&lt; <span class="stringliteral">&quot; after&quot;</span>;
<a name="l00163"></a>00163         cout &lt;&lt; endl;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00171"></a><a class="code" href="class_power_state_graph.html#aae4db4000f6485559f06ab4de4d54619">00171</a> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="class_power_state_graph.html#aae4db4000f6485559f06ab4de4d54619" title="Determine the index of the next spike after spike.">PowerStateGraph::indexOfNextSpike</a>(
<a name="l00172"></a>00172         <span class="keyword">const</span> list&lt;Signature::Spike&gt;&amp; spikes,
<a name="l00173"></a>00173         list&lt;Signature::Spike&gt;::iterator spike,
<a name="l00174"></a>00174         <span class="keyword">const</span> <a class="code" href="class_signature.html" title="Class for storing a Device&amp;#39;s signature recorded by, for example, a Watts Up plug-in power logger...">Signature</a>&amp; sig
<a name="l00175"></a>00175         )<span class="keyword"> const</span>
<a name="l00176"></a>00176 <span class="keyword"></span>{
<a name="l00177"></a>00177     list&lt;Signature::Spike&gt;::iterator spikePlusOne = spike;
<a name="l00178"></a>00178     spikePlusOne++;
<a name="l00179"></a>00179     <span class="keywordflow">if</span> (spikePlusOne != spikes.end())
<a name="l00180"></a>00180         <span class="keywordflow">return</span> spikePlusOne-&gt;index;
<a name="l00181"></a>00181     <span class="keywordflow">else</span>
<a name="l00182"></a>00182         <span class="keywordflow">return</span> sig.<a class="code" href="class_array.html#ae16b42080e87a53fe2b76af98995111b">getSize</a>() - 1;
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00189"></a><a class="code" href="class_power_state_graph.html#a84bbbefd53f67b2945ac17eb11e28fdf">00189</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="class_power_state_graph.html#a84bbbefd53f67b2945ac17eb11e28fdf" title="Decides whether or not to reject this spike based on the before and after statistics.">PowerStateGraph::rejectSpike</a>(
<a name="l00190"></a>00190         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; before,
<a name="l00191"></a>00191         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; after,
<a name="l00192"></a>00192         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00193"></a>00193         )<span class="keyword"> const</span>
<a name="l00194"></a>00194 <span class="keyword"></span>{
<a name="l00195"></a>00195     <span class="comment">// check the stdev isn&#39;t too large</span>
<a name="l00196"></a>00196     <span class="keywordflow">if</span> ( (before.<a class="code" href="struct_statistic.html#aa7f372e3416ed9a7f36e7796a7230713">stdev</a> &gt; fabs(before.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>)) ||
<a name="l00197"></a>00197          ( after.<a class="code" href="struct_statistic.html#aa7f372e3416ed9a7f36e7796a7230713">stdev</a> &gt; fabs(after.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>))   ) {
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;stdev too big&quot;</span>;
<a name="l00199"></a>00199         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="comment">// check the means aren&#39;t too close</span>
<a name="l00203"></a>00203     <span class="keywordflow">if</span> (<a class="code" href="namespace_utils.html#a0f28dbdddde3ce309eba6afb7d1f2785">Utils::within</a>(before.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>, after.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>, <a class="code" href="namespace_utils.html#a6c1d66956e07544cec585bc664b93c4d">Utils::highest</a>(before.<a class="code" href="struct_statistic.html#aa7f372e3416ed9a7f36e7796a7230713">stdev</a>, after.<a class="code" href="struct_statistic.html#aa7f372e3416ed9a7f36e7796a7230713">stdev</a>)*2) ||
<a name="l00204"></a>00204         <a class="code" href="namespace_utils.html#a0f28dbdddde3ce309eba6afb7d1f2785">Utils::within</a>(before.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>, after.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>, <a class="code" href="namespace_utils.html#a6c1d66956e07544cec585bc664b93c4d">Utils::highest</a>(before.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>, after.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>)*0.2)     ) {
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;means too close&quot;</span>;
<a name="l00206"></a>00206         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="comment">// if we get to here then don&#39;t reject</span>
<a name="l00210"></a>00210     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00221"></a><a class="code" href="class_power_state_graph.html#ac36cccb3fb0281f9b68e39ba28737770">00221</a> PowerStateGraph::PSGraph::vertex_descriptor <a class="code" href="class_power_state_graph.html#ac36cccb3fb0281f9b68e39ba28737770" title="Attempts to find an existing vertex which is statistically similar to stat. If an existing similar ve...">PowerStateGraph::updateOrInsertVertex</a>(
<a name="l00222"></a>00222         <span class="keyword">const</span> <a class="code" href="class_signature.html" title="Class for storing a Device&amp;#39;s signature recorded by, for example, a Watts Up plug-in power logger...">Signature</a>&amp; sig, 
<a name="l00223"></a>00223         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; postSpikePowerState,
<a name="l00224"></a>00224         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; betweenSpikesPowerState,
<a name="l00225"></a>00225         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose  
<a name="l00226"></a>00226     )
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228     <span class="keywordtype">bool</span> foundSimilar; <span class="comment">// return param for mostSimilarVertex()</span>
<a name="l00229"></a>00229     PSGraph::vertex_descriptor vertex = <a class="code" href="class_power_state_graph.html#a7420e492ce4608c1a4dbba027af116c0" title="Find the vertex statistically most similarto stat.">mostSimilarVertex</a>( &amp;foundSimilar, postSpikePowerState );
<a name="l00230"></a>00230     <span class="comment">// mostSimilarVertex() uses a T-Test to find the powerStateGraph</span>
<a name="l00231"></a>00231     <span class="comment">// vertex with a mean most similar to postSpikePowerState.</span>
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (verbose)
<a name="l00234"></a>00234         cout &lt;&lt; <span class="stringliteral">&quot; mostSimlar = &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike &lt;&lt; endl;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="keywordflow">if</span> ( foundSimilar ) {
<a name="l00237"></a>00237         <span class="keywordflow">if</span> (vertex != <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>) {
<a name="l00238"></a>00238             <span class="comment">// Update an existing vertex</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240             <span class="keywordflow">if</span> (verbose) {
<a name="l00241"></a>00241                 cout &lt;&lt; endl
<a name="l00242"></a>00242                         &lt;&lt; <span class="stringliteral">&quot;Updating existing vertex: &quot;</span> &lt;&lt; endl
<a name="l00243"></a>00243                         &lt;&lt; <span class="stringliteral">&quot;    existing vertex = &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike &lt;&lt; endl
<a name="l00244"></a>00244                         &lt;&lt; <span class="stringliteral">&quot;    new stat        = &quot;</span> &lt;&lt; postSpikePowerState &lt;&lt; endl;
<a name="l00245"></a>00245             }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247             <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike.update( postSpikePowerState );
<a name="l00248"></a>00248             <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].betweenSpikes.update( betweenSpikesPowerState );
<a name="l00249"></a>00249 
<a name="l00250"></a>00250             <span class="keywordflow">if</span> (verbose)
<a name="l00251"></a>00251                 cout &lt;&lt; <span class="stringliteral">&quot;    merged          = &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike &lt;&lt; endl;
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253     } <span class="keywordflow">else</span> {
<a name="l00254"></a>00254         <span class="comment">// Add a new vertex</span>
<a name="l00255"></a>00255         vertex = add_vertex(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00256"></a>00256         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike = postSpikePowerState;
<a name="l00257"></a>00257         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].betweenSpikes = betweenSpikesPowerState;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (verbose) {
<a name="l00260"></a>00260             cout &lt;&lt; endl
<a name="l00261"></a>00261                  &lt;&lt; <span class="stringliteral">&quot;Adding new vertex: &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike &lt;&lt; endl;
<a name="l00262"></a>00262         }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     <span class="keywordflow">return</span> vertex;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00277"></a><a class="code" href="class_power_state_graph.html#a7420e492ce4608c1a4dbba027af116c0">00277</a> PowerStateGraph::PSGraph::vertex_descriptor <a class="code" href="class_power_state_graph.html#a7420e492ce4608c1a4dbba027af116c0" title="Find the vertex statistically most similarto stat.">PowerStateGraph::mostSimilarVertex</a>(
<a name="l00278"></a>00278         <span class="keywordtype">bool</span> * success, 
<a name="l00279"></a>00279         <span class="keyword">const</span> <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>&amp; stat, 
<a name="l00280"></a>00280         <span class="keyword">const</span> <span class="keywordtype">double</span> ALPHA 
<a name="l00281"></a>00281     )<span class="keyword"> const</span>
<a name="l00282"></a>00282 <span class="keyword"></span>{
<a name="l00283"></a>00283     PSGraph::vertex_descriptor vertex=0;
<a name="l00284"></a>00284     std::pair&lt;PSG_vertex_iter, PSG_vertex_iter&gt; vp;
<a name="l00285"></a>00285     <span class="keywordtype">double</span> tTest, highestTTest=0;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="comment">// Find the best fit</span>
<a name="l00288"></a>00288     <span class="keywordflow">for</span> (vp = boost::vertices(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>); vp.first != vp.second; ++vp.first) {
<a name="l00289"></a>00289         <span class="comment">// t test</span>
<a name="l00290"></a>00290         tTest = stat.<a class="code" href="struct_statistic.html#a2809624bf38cbe0817c3c5e3c2639c71" title="A two-sided Student T-Test.">tTest</a>( <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*vp.first].postSpike );
<a name="l00291"></a>00291         <span class="keywordflow">if</span> (tTest &gt; highestTTest) {
<a name="l00292"></a>00292             highestTTest = tTest;
<a name="l00293"></a>00293             vertex = *vp.first;
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="comment">// Check whether the best fit is satisfactory</span>
<a name="l00299"></a>00299     <span class="keywordflow">if</span> ( (highestTTest &gt; (ALPHA/2)) <span class="comment">// T-Test</span>
<a name="l00300"></a>00300        ||  ( <a class="code" href="namespace_utils.html#a0f28dbdddde3ce309eba6afb7d1f2785">Utils::within</a>
<a name="l00301"></a>00301                  (
<a name="l00302"></a>00302                  <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike.mean,
<a name="l00303"></a>00303                  stat.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>,
<a name="l00304"></a>00304                  (<a class="code" href="namespace_utils.html#a6c1d66956e07544cec585bc664b93c4d">Utils::highest</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[vertex].postSpike.mean, stat.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a>) * 0.2)
<a name="l00305"></a>00305                  ) <span class="comment">// check if the means are within 20% of each other</span>
<a name="l00306"></a>00306          )
<a name="l00307"></a>00307       )
<a name="l00308"></a>00308         *success = <span class="keyword">true</span>;
<a name="l00309"></a>00309     <span class="keywordflow">else</span>
<a name="l00310"></a>00310         *success = <span class="keyword">false</span>;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keywordflow">return</span> vertex;
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00329"></a><a class="code" href="class_power_state_graph.html#a0e3e05ae1b952132621425c042d84ec1">00329</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a0e3e05ae1b952132621425c042d84ec1" title="Update or Insert a new edge into powerStateGraph.">PowerStateGraph::updateOrInsertEdge</a>(
<a name="l00330"></a>00330         <span class="keyword">const</span> PSGraph::vertex_descriptor&amp; beforeVertex,
<a name="l00331"></a>00331         <span class="keyword">const</span> PSGraph::vertex_descriptor&amp; afterVertex,
<a name="l00332"></a>00332         <span class="keyword">const</span> <span class="keywordtype">size_t</span> samplesSinceLastSpike,
<a name="l00333"></a>00333         <span class="keyword">const</span> <span class="keywordtype">double</span> spikeDelta,
<a name="l00334"></a>00334         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00335"></a>00335         )
<a name="l00336"></a>00336 {
<a name="l00337"></a>00337     <a class="code" href="class_power_state_graph.html#a2488f22b81a37936243ff1e3493c6c9b" title="the total number of times any edge has been traversed during training.">totalCount</a>++;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;-------------------&quot;</span> &lt;&lt; endl;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     PSGraph::edge_descriptor existingEdge, newEdge;
<a name="l00342"></a>00342     <span class="keywordtype">bool</span> edgeExistsAlready;
<a name="l00343"></a>00343     tie(existingEdge, edgeExistsAlready) = boost::edge(beforeVertex, afterVertex, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     <span class="keywordflow">if</span> (verbose) {
<a name="l00346"></a>00346         <span class="keywordflow">if</span> ( edgeExistsAlready ) {
<a name="l00347"></a>00347             cout &lt;&lt; <span class="stringliteral">&quot;edgeExistsAlready&quot;</span> &lt;&lt; endl;
<a name="l00348"></a>00348         } <span class="keywordflow">else</span> {
<a name="l00349"></a>00349             cout &lt;&lt; <span class="stringliteral">&quot;edge does not Exist Already&quot;</span> &lt;&lt; endl;
<a name="l00350"></a>00350         }
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     <span class="keywordflow">if</span> ( edgeExistsAlready ) {
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="keywordflow">if</span> (verbose) {
<a name="l00356"></a>00356             <span class="keywordflow">for</span> (list&lt;PSGraph::edge_descriptor&gt;::iterator edge=<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.begin(); edge!=<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.end(); edge++) {
<a name="l00357"></a>00357                 cout &lt;&lt; <span class="stringliteral">&quot;                              edgeHistory = &quot;</span> &lt;&lt; *edge &lt;&lt; endl;
<a name="l00358"></a>00358             }
<a name="l00359"></a>00359             <span class="keywordflow">for</span> (list&lt;PSGraph::edge_descriptor&gt;::iterator edge=<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[existingEdge].<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>.begin();
<a name="l00360"></a>00360                     edge!=<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[existingEdge].edgeHistory.end(); edge++) {
<a name="l00361"></a>00361                 cout &lt;&lt; <span class="stringliteral">&quot;powerStateGraph[existingEdge].edgeHistory = &quot;</span> &lt;&lt; *edge &lt;&lt; endl;
<a name="l00362"></a>00362             }
<a name="l00363"></a>00363             cout &lt;&lt; endl;
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="comment">// check if any of the out edges from beforeVertex have the same</span>
<a name="l00367"></a>00367         <span class="comment">// history as our current history... if so, update that edge.</span>
<a name="l00368"></a>00368         PSGraph::out_edge_iterator out_e_i, out_e_end;
<a name="l00369"></a>00369         tie(out_e_i, out_e_end) = out_edges(beforeVertex, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00370"></a>00370         <span class="keywordflow">for</span> (; out_e_i != out_e_end; out_e_i++) {
<a name="l00371"></a>00371             <span class="comment">// check if the edge has the same history and same sign delta and is within 3 stdevs of the existing delta</span>
<a name="l00372"></a>00372             <span class="keywordflow">if</span> ( <a class="code" href="class_power_state_graph.html#a6de44e31afe85bf0ee18dc09a7be329c" title="Check if edge list a and edge list b are equal.">edgeListsAreEqual</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>, edgeHistory) &amp;&amp;
<a name="l00373"></a>00373                     <a class="code" href="namespace_utils.html#a297beaecb52c2c24b05b9666d080bb7e" title="Returns true if a and b are the same sign. Zero is assumed to be positive.">Utils::sameSign</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].delta.mean, spikeDelta ) &amp;&amp;
<a name="l00374"></a>00374                     <a class="code" href="namespace_utils.html#a0f28dbdddde3ce309eba6afb7d1f2785">Utils::within</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].delta.mean,
<a name="l00375"></a>00375                             spikeDelta, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].delta.nonZeroStdev()*3 )) {
<a name="l00376"></a>00376 
<a name="l00377"></a>00377                 <span class="keywordflow">if</span> (verbose) {
<a name="l00378"></a>00378                     cout &lt;&lt; <span class="stringliteral">&quot;edge histories the same. merging with&quot;</span> &lt;&lt; *out_e_i
<a name="l00379"></a>00379                             &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].delta &lt;&lt; endl;
<a name="l00380"></a>00380                 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382                 <span class="comment">// update existing edge&#39;s stats</span>
<a name="l00383"></a>00383                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].delta.update( spikeDelta );
<a name="l00384"></a>00384                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].duration.update( samplesSinceLastSpike );
<a name="l00385"></a>00385                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i].count++;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387                 <a class="code" href="class_power_state_graph.html#ae3eaaaca0f80786469b8674991db9476">addItemToEdgeHistory</a>( *out_e_i );
<a name="l00388"></a>00388 
<a name="l00389"></a>00389                 <span class="keywordflow">return</span>;
<a name="l00390"></a>00390             }
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     <span class="comment">// if we get to here then we know that either:</span>
<a name="l00395"></a>00395     <span class="comment">//    an edge doesn&#39;t already exist between these 2 vertices</span>
<a name="l00396"></a>00396     <span class="comment">// or</span>
<a name="l00397"></a>00397     <span class="comment">//    an edge does exist but it doesn&#39;t share our history.</span>
<a name="l00398"></a>00398     <span class="comment">// either way, we need to add a new edge:</span>
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     tie(newEdge, edgeExistsAlready) = boost::add_edge(beforeVertex, afterVertex, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00401"></a>00401     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].delta    = <a class="code" href="struct_statistic.html">Statistic&lt;double&gt;</a>( spikeDelta );
<a name="l00402"></a>00402     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].duration = <a class="code" href="struct_statistic.html">Statistic&lt;size_t&gt;</a>( samplesSinceLastSpike );
<a name="l00403"></a>00403     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].count    = 1;
<a name="l00404"></a>00404     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].edgeHistory = <a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="keywordflow">if</span> (verbose) {
<a name="l00407"></a>00407         cout &lt;&lt; <span class="stringliteral">&quot;adding new edge&quot;</span> &lt;&lt; newEdge &lt;&lt; endl
<a name="l00408"></a>00408             &lt;&lt; <span class="stringliteral">&quot;   delta stats    = &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].delta &lt;&lt; endl
<a name="l00409"></a>00409             &lt;&lt; <span class="stringliteral">&quot;   duration stats = &quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[newEdge].duration &lt;&lt; endl;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     <a class="code" href="class_power_state_graph.html#ae3eaaaca0f80786469b8674991db9476">addItemToEdgeHistory</a>( newEdge );
<a name="l00413"></a>00413 }
<a name="l00414"></a>00414 
<a name="l00418"></a><a class="code" href="class_power_state_graph.html#a6de44e31afe85bf0ee18dc09a7be329c">00418</a> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="class_power_state_graph.html#a6de44e31afe85bf0ee18dc09a7be329c" title="Check if edge list a and edge list b are equal.">PowerStateGraph::edgeListsAreEqual</a>(
<a name="l00419"></a>00419         <span class="keyword">const</span> list&lt; PSGraph::edge_descriptor &gt;&amp; a,
<a name="l00420"></a>00420         <span class="keyword">const</span> list&lt; PSGraph::edge_descriptor &gt;&amp; b,
<a name="l00421"></a>00421         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00422"></a>00422         )<span class="keyword"> const</span>
<a name="l00423"></a>00423 <span class="keyword"></span>{
<a name="l00424"></a>00424     <span class="comment">// Check if edge histories are disabled</span>
<a name="l00425"></a>00425     <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a> == 0)
<a name="l00426"></a>00426         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">//******************* DIAGNOSTICS *******************</span>
<a name="l00429"></a>00429     <span class="keywordflow">if</span> (verbose ) {
<a name="l00430"></a>00430         cout &lt;&lt; <span class="stringliteral">&quot;************&quot;</span> &lt;&lt; endl
<a name="l00431"></a>00431                 &lt;&lt; <span class="stringliteral">&quot;comparing lists:&quot;</span> &lt;&lt; endl;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="keywordflow">for</span> (list&lt; PSGraph::edge_descriptor &gt;::const_iterator i=a.begin(); i!=a.end(); i++) {
<a name="l00434"></a>00434             cout &lt;&lt; *i &lt;&lt; endl;
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436         cout &lt;&lt; <span class="stringliteral">&quot;----&quot;</span> &lt;&lt; endl;
<a name="l00437"></a>00437         <span class="keywordflow">for</span> (list&lt; PSGraph::edge_descriptor &gt;::const_iterator i=b.begin(); i!=b.end(); i++) {
<a name="l00438"></a>00438             cout &lt;&lt; *i &lt;&lt; endl;
<a name="l00439"></a>00439         }
<a name="l00440"></a>00440     }<span class="comment">//___________________________________________________</span>
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (a.size() != b.size()) {
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;sizes not equal&quot;</span> &lt;&lt; endl;
<a name="l00444"></a>00444         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;************&quot;</span> &lt;&lt; endl;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449     list&lt;PSGraph::edge_descriptor&gt;::const_iterator a_i, b_i;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451     a_i = a.begin();
<a name="l00452"></a>00452     b_i = b.begin();
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="keywordflow">while</span> (a_i != a.end() &amp;&amp; b_i != b.end()) {
<a name="l00455"></a>00455 
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;*a_i=&quot;</span> &lt;&lt; *a_i &lt;&lt; <span class="stringliteral">&quot; *b_i=&quot;</span> &lt;&lt; *b_i &lt;&lt; endl;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         <span class="keywordflow">if</span> ( source(*a_i, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>) != source(*b_i, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>) &amp;&amp;
<a name="l00459"></a>00459              target(*a_i, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>) != target(*b_i, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>)   ) {
<a name="l00460"></a>00460 
<a name="l00461"></a>00461             <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;edge list are not equal&quot;</span> &lt;&lt; endl &lt;&lt; endl;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00464"></a>00464         }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         a_i++;
<a name="l00467"></a>00467         b_i++;
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00494"></a><a class="code" href="class_power_state_graph.html#a26384a0a6d9867d336814b70b7a22cd3">00494</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a26384a0a6d9867d336814b70b7a22cd3" title="Update (or create) directional edges between power states (vertices) so the edges are consistent with...">PowerStateGraph::updateEdges</a>( <span class="keyword">const</span> <a class="code" href="class_signature.html" title="Class for storing a Device&amp;#39;s signature recorded by, for example, a Watts Up plug-in power logger...">Signature</a>&amp; sig )
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496     <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a> nextPowerState, prevPowerState;
<a name="l00497"></a>00497     PSGraph::vertex_descriptor mostSimVertex, previousVertex;
<a name="l00498"></a>00498     pair&lt;PSGraph::edge_descriptor, bool&gt; addedEdge;
<a name="l00499"></a>00499     <span class="keywordtype">size_t</span> previousIndex;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     <span class="comment">// get the gradient spikes for the first signature</span>
<a name="l00502"></a>00502     list&lt;Signature::Spike&gt; spikes = sig.<a class="code" href="class_signature.html#a02acc8e9f1ceb1af2908807eb1526fcd" title="Takes the gradient of this Signature, then merges gradient values with the same sign, then removes transient spikes, then sorts by value.">getDeltaSpikes</a>();
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <span class="comment">// take just the top ten (whilst ordered by absolute value)</span>
<a name="l00505"></a>00505     <span class="keywordflow">if</span> (spikes.size() &gt; 10) {
<a name="l00506"></a>00506         list&lt;Signature::Spike&gt;::iterator it = spikes.begin();
<a name="l00507"></a>00507         advance( it, 10 );
<a name="l00508"></a>00508         spikes.erase( it, spikes.end() );
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     <span class="comment">// re-order by index (i.e. by time)</span>
<a name="l00512"></a>00512     spikes.sort( <a class="code" href="struct_signature_1_1_spike.html#ad5c457fd1b72cd723bdf89f715f34abd">Signature::Spike::compareIndexAsc</a> );
<a name="l00513"></a>00513 
<a name="l00514"></a>00514     <span class="comment">// calculate stats for the signature&#39;s values between start and first spike</span>
<a name="l00515"></a>00515     <span class="comment">// as long as the first spike-&gt;index &gt; 1</span>
<a name="l00516"></a>00516     previousVertex = <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>;
<a name="l00517"></a>00517     previousIndex  = 0;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     list&lt;Signature::Spike&gt;::iterator spike, prevSpike;
<a name="l00520"></a>00520     prevSpike = spike = spikes.begin();
<a name="l00521"></a>00521     advance(spike, 1);
<a name="l00522"></a>00522     <span class="keywordflow">for</span> (; spike!=spikes.end(); spike++ ) {
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         nextPowerState = <a class="code" href="struct_statistic.html">Statistic&lt;Sample_t&gt;</a>( sig, prevSpike-&gt;index+1, prevSpike-&gt;index+10); <span class="comment">// spike-&gt;index);</span>
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keywordtype">bool</span> foundSimilar;
<a name="l00527"></a>00527         mostSimVertex = <a class="code" href="class_power_state_graph.html#a7420e492ce4608c1a4dbba027af116c0" title="Find the vertex statistically most similarto stat.">mostSimilarVertex</a>( &amp;foundSimilar, nextPowerState, 0.1 );
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         <span class="keywordflow">if</span> (foundSimilar &amp;&amp; previousVertex!=mostSimVertex) {
<a name="l00530"></a>00530             <span class="comment">/* Add an edge from previousVertex to mostSimVertex.</span>
<a name="l00531"></a>00531 <span class="comment">             * If an edge already exists then boost::add_edge will</span>
<a name="l00532"></a>00532 <span class="comment">             * return an edge_descriptor to that edge. */</span>
<a name="l00533"></a>00533             addedEdge = boost::add_edge(previousVertex, mostSimVertex, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00534"></a>00534 
<a name="l00535"></a>00535             <span class="keywordflow">if</span> (addedEdge.second) { <span class="comment">// then there was not an edge already in the graph</span>
<a name="l00536"></a>00536                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].delta =
<a name="l00537"></a>00537                         <a class="code" href="struct_statistic.html">Statistic&lt;double&gt;</a>( prevSpike-&gt;delta );
<a name="l00538"></a>00538                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].duration =
<a name="l00539"></a>00539                         <a class="code" href="struct_statistic.html">Statistic&lt;size_t&gt;</a>( prevSpike-&gt;index - previousIndex );
<a name="l00540"></a>00540                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].count = 1;
<a name="l00541"></a>00541                 <a class="code" href="class_power_state_graph.html#a2488f22b81a37936243ff1e3493c6c9b" title="the total number of times any edge has been traversed during training.">totalCount</a>++;
<a name="l00542"></a>00542             } <span class="keywordflow">else</span> { <span class="comment">// there was an edge already in the graph so update that edge</span>
<a name="l00543"></a>00543                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].delta.update( prevSpike-&gt;delta );
<a name="l00544"></a>00544                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].duration.update( prevSpike-&gt;index - previousIndex );
<a name="l00545"></a>00545                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].count++;
<a name="l00546"></a>00546                 <a class="code" href="class_power_state_graph.html#a2488f22b81a37936243ff1e3493c6c9b" title="the total number of times any edge has been traversed during training.">totalCount</a>++;
<a name="l00547"></a>00547             }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549             previousIndex  = prevSpike-&gt;index;
<a name="l00550"></a>00550             previousVertex = mostSimVertex;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552         prevSpike = spike;
<a name="l00553"></a>00553     }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     <span class="comment">// add the last edge back to &quot;off&quot;</span>
<a name="l00556"></a>00556     addedEdge = boost::add_edge(previousVertex, <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00557"></a>00557     <span class="keywordflow">if</span> (addedEdge.second) { <span class="comment">// then there was not an edge already in the graph</span>
<a name="l00558"></a>00558         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].delta =
<a name="l00559"></a>00559                 <a class="code" href="struct_statistic.html">Statistic&lt;double&gt;</a>( prevSpike-&gt;delta );
<a name="l00560"></a>00560         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].duration =
<a name="l00561"></a>00561                 <a class="code" href="struct_statistic.html">Statistic&lt;size_t&gt;</a>( prevSpike-&gt;index - previousIndex );
<a name="l00562"></a>00562         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].count = 1;
<a name="l00563"></a>00563         <a class="code" href="class_power_state_graph.html#a2488f22b81a37936243ff1e3493c6c9b" title="the total number of times any edge has been traversed during training.">totalCount</a>++;
<a name="l00564"></a>00564     } <span class="keywordflow">else</span> { <span class="comment">// there was an edge already in the graph so update that edge</span>
<a name="l00565"></a>00565         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].delta.update( prevSpike-&gt;delta );
<a name="l00566"></a>00566         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].duration.update( prevSpike-&gt;index - previousIndex );
<a name="l00567"></a>00567         <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[addedEdge.first].count++;
<a name="l00568"></a>00568         <a class="code" href="class_power_state_graph.html#a2488f22b81a37936243ff1e3493c6c9b" title="the total number of times any edge has been traversed during training.">totalCount</a>++;
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 
<a name="l00576"></a><a class="code" href="class_power_state_graph.html#a52095959446302223b8c436e1aa49e50">00576</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a52095959446302223b8c436e1aa49e50" title="Information about an entire device &amp;#39;fingerprint&amp;#39; found in the aggregate data.">PowerStateGraph::writeGraphViz</a>(ostream&amp; out)
<a name="l00577"></a>00577 {
<a name="l00578"></a>00578     write_graphviz(
<a name="l00579"></a>00579             out,
<a name="l00580"></a>00580             <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>,
<a name="l00581"></a>00581             <a class="code" href="struct_power_state_graph_1_1_p_s_g__vertex__writer.html">PSG_vertex_writer</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>),
<a name="l00582"></a>00582             <a class="code" href="struct_power_state_graph_1_1_p_s_g__edge__writer.html">PSG_edge_writer</a>(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>)
<a name="l00583"></a>00583             );
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00612"></a><a class="code" href="class_power_state_graph.html#a3823f720987e5e13eb7f1cfae7cdf4be">00612</a> <span class="keyword">const</span> list&lt;PowerStateGraph::Fingerprint&gt; <a class="code" href="class_power_state_graph.html#a3823f720987e5e13eb7f1cfae7cdf4be" title="This is the main public interface to the disaggregation algorithm.">PowerStateGraph::disaggregate</a>(
<a name="l00613"></a>00613         <span class="keyword">const</span> <a class="code" href="class_aggregate_data.html" title="This class is responsible for storing and searching aggregated data, such as the data produced by the...">AggregateData</a>&amp; aggregateData, 
<a name="l00614"></a>00614         <span class="keyword">const</span> <span class="keywordtype">bool</span> keep_overlapping, 
<a name="l00615"></a>00615         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00616"></a>00616         )
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618     cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;***** TRAINING FINISHED. DISAGGREGATION STARTING. *****&quot;</span> &lt;&lt; endl &lt;&lt; endl;
<a name="l00619"></a>00619     cout &lt;&lt; <span class="stringliteral">&quot;Finding start deltas...&quot;</span>;
<a name="l00620"></a>00620     cout.flush();
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <span class="keywordflow">if</span> (num_vertices( <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a> ) &lt; 2) {
<a name="l00623"></a>00623         <a class="code" href="namespace_utils.html#a5f35365dae06a93f4bbf0f406a78b90b">Utils::fatalError</a>( <span class="stringliteral">&quot;powerStateGraph is empty. Cannot continue with disaggregation.&quot;</span> );
<a name="l00624"></a>00624     }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626     <span class="comment">// Store a pointer to aggregateData for use later.</span>
<a name="l00627"></a>00627     <a class="code" href="class_power_state_graph.html#a72bfd26474a03ee600df77aada105c75">aggData</a> = &amp;aggregateData;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     <span class="comment">/* Fingerprint is a struct for bundling start</span>
<a name="l00630"></a>00630 <span class="comment">     * timestamp, duration, energy and avLikelihood */</span>
<a name="l00631"></a>00631     list&lt;Fingerprint&gt; fingerprintList; <span class="comment">// what we return</span>
<a name="l00632"></a>00632     <a class="code" href="struct_power_state_graph_1_1_fingerprint.html">Fingerprint</a> candidateFingerprint;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="comment">/* Load the stats from the first PowerStateGraph edge.</span>
<a name="l00635"></a>00635 <span class="comment">     * The Boost Graph Lib provides an out_edges() function which returns</span>
<a name="l00636"></a>00636 <span class="comment">     * a pair of edge iterators: the first iterator points to the first edge;</span>
<a name="l00637"></a>00637 <span class="comment">     * the second iterator points 1 past the last edge. Dereferencing an</span>
<a name="l00638"></a>00638 <span class="comment">     * edge iterator returns an edge descriptor. tie() allows easy</span>
<a name="l00639"></a>00639 <span class="comment">     * access to each element of the pair of edge iterators. */</span>
<a name="l00640"></a>00640     <a class="code" href="class_power_state_graph.html#a0076074a11b3c6de4ceeb6bb24714656">PSG_out_edge_iter</a> out_i, out_end;
<a name="l00641"></a>00641     tie(out_i, out_end) = out_edges(<a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00642"></a>00642     <a class="code" href="struct_power_state_graph_1_1_power_state_edge.html">PowerStateEdge</a> firstEdgeStats = <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_i];
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="comment">// Search through aggregateData for possible start spikes</span>
<a name="l00645"></a>00645     list&lt;AggregateData::FoundSpike&gt; posStartSpikes
<a name="l00646"></a>00646         = aggregateData.<a class="code" href="class_aggregate_data.html#ada468d155767d721c755405582d108ee" title="Find all spikes in aggregate data which fit spikeStats.">findSpike</a>(firstEdgeStats.<a class="code" href="struct_power_state_graph_1_1_power_state_edge.html#a836fb8fcc81e3a1f9513a0f7079a0ebf">delta</a>);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     cout &lt;&lt; <span class="stringliteral">&quot; found &quot;</span> &lt;&lt; posStartSpikes.size() &lt;&lt; <span class="stringliteral">&quot; possible start deltas. Following through... &quot;</span> &lt;&lt; endl;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     <span class="comment">// For each possible start spike in the delta aggregate, attempt</span>
<a name="l00651"></a>00651     <span class="comment">// to find all the subsequent spikes specified by powerStateGraph edges.</span>
<a name="l00652"></a>00652     <span class="keywordflow">for</span> (list&lt;AggregateData::FoundSpike&gt;::const_iterator posStartSpike=posStartSpikes.begin();
<a name="l00653"></a>00653             posStartSpike!=posStartSpikes.end();
<a name="l00654"></a>00654             posStartSpike++) {
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         <span class="comment">// Attempt to recursively &quot;follow through&quot; from this posStartSpike.</span>
<a name="l00657"></a>00657         <span class="comment">// initTraceToEnd() calls the recursive function traceToEnd().</span>
<a name="l00658"></a>00658         candidateFingerprint = <a class="code" href="class_power_state_graph.html#a0478f171d51d21613746640c7415fb0b">initTraceToEnd</a>(
<a name="l00659"></a>00659                 *posStartSpike,
<a name="l00660"></a>00660                 ( posStartSpike-&gt;timestamp - firstEdgeStats.<a class="code" href="struct_power_state_graph_1_1_power_state_edge.html#a7c1f13510581d9a999edeb5aadf34c96">duration</a>.<a class="code" href="struct_statistic.html#ad2bc37d454c97cfd7187f767263ba208">mean</a> ) <span class="comment">// time the device probably started</span>
<a name="l00661"></a>00661                 );
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         <span class="comment">// If this start spike was successfully traced all the way to</span>
<a name="l00664"></a>00664         <span class="comment">// an off power state then add this item to fingerprintList.</span>
<a name="l00665"></a>00665         <span class="keywordflow">if</span> ( candidateFingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> != -1 ) {
<a name="l00666"></a>00666             fingerprintList.push_back( candidateFingerprint );
<a name="l00667"></a>00667             <span class="keywordflow">if</span> (verbose)
<a name="l00668"></a>00668                 cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;candidate found at &quot;</span> &lt;&lt; endl &lt;&lt; candidateFingerprint &lt;&lt; endl;
<a name="l00669"></a>00669             <span class="keywordflow">else</span> {
<a name="l00670"></a>00670                 cout &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l00671"></a>00671                 cout.flush();
<a name="l00672"></a>00672             }
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     cout &lt;&lt; endl;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="keywordflow">if</span> ( fingerprintList.empty() ) {
<a name="l00679"></a>00679         cout &lt;&lt; <span class="stringliteral">&quot;No signatures found.&quot;</span> &lt;&lt; endl;
<a name="l00680"></a>00680     } <span class="keywordflow">else</span> {
<a name="l00681"></a>00681         <span class="keywordflow">if</span> (!keep_overlapping) {
<a name="l00682"></a>00682             <a class="code" href="class_power_state_graph.html#a5ef8ee81761b13f9f16b564aca228994">removeOverlapping</a>( &amp;fingerprintList );
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <a class="code" href="class_power_state_graph.html#a8c7b40b543c04d5f5b498a537093ae46">displayAndPlotFingerprintList</a>( fingerprintList, aggregateData.<a class="code" href="class_aggregate_data.html#aacf47acf1ff8001aebdcdf078c551358">getFilename</a>() );
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="keywordflow">return</span> fingerprintList;
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a><a class="code" href="class_power_state_graph.html#a8c7b40b543c04d5f5b498a537093ae46">00691</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a8c7b40b543c04d5f5b498a537093ae46">PowerStateGraph::displayAndPlotFingerprintList</a>(
<a name="l00692"></a>00692         <span class="keyword">const</span> list&lt; Fingerprint &gt;&amp; fingerprintList,
<a name="l00693"></a>00693         <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; aggDataFilename
<a name="l00694"></a>00694         )<span class="keyword"> const</span>
<a name="l00695"></a>00695 <span class="keyword"></span>{
<a name="l00696"></a>00696     cout &lt;&lt; <span class="stringliteral">&quot;Displaying disaggregation data and dumping to file for plotting. &quot;</span> &lt;&lt; endl;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     fstream fs;
<a name="l00699"></a>00699     <a class="code" href="namespace_utils.html#afb991f08a33e9d7f3298e60f3bf76960">Utils::openFile</a>(fs, <a class="code" href="_common_8h.html#a478275f2b00467a503a0b689f32e096f">DATA_OUTPUT_PATH</a> + <span class="stringliteral">&quot;disagg.dat&quot;</span>, fstream::out);
<a name="l00700"></a>00700     list&lt;Fingerprint&gt;::const_iterator disagItem;
<a name="l00701"></a>00701     <span class="keywordtype">size_t</span> count = 0;
<a name="l00702"></a>00702     <span class="keywordflow">for</span> (disagItem=fingerprintList.begin(); disagItem!=fingerprintList.end(); disagItem++) {
<a name="l00703"></a>00703         cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Candidate fingerprint found: &quot;</span> &lt;&lt; endl &lt;&lt; *disagItem &lt;&lt; endl;
<a name="l00704"></a>00704         count++;
<a name="l00705"></a>00705         <span class="keywordflow">for</span> (list&lt;TimeAndPower&gt;::const_iterator tap_i=disagItem-&gt;timeAndPower.begin();
<a name="l00706"></a>00706                 tap_i!=disagItem-&gt;timeAndPower.end(); tap_i++) {
<a name="l00707"></a>00707             fs &lt;&lt; tap_i-&gt;timestamp &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; tap_i-&gt;meanPower &lt;&lt; endl;
<a name="l00708"></a>00708         }
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710     cout &lt;&lt; endl
<a name="l00711"></a>00711             &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot; candidate&quot;</span> &lt;&lt; (count==1 ? <span class="stringliteral">&quot;. &quot;</span> : <span class="stringliteral">&quot;s.&quot;</span> ) &lt;&lt; endl;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <span class="comment">// Calculate size of x-axis border</span>
<a name="l00714"></a>00714     <span class="keyword">const</span> <span class="keywordtype">size_t</span> begOfFirstFingerprint = fingerprintList.front().timestamp;
<a name="l00715"></a>00715     <span class="keyword">const</span> <span class="keywordtype">size_t</span> endOfLastFingerprint  = fingerprintList.back().timestamp + fingerprintList.back().duration;
<a name="l00716"></a>00716     <span class="keyword">const</span> <span class="keywordtype">size_t</span> BORDER = (endOfLastFingerprint - begOfFirstFingerprint) / 10;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="comment">// Set Plot variables</span>
<a name="l00719"></a>00719     <a class="code" href="struct_g_n_uplot_1_1_plot_vars.html" title="Structure for storing variables destined for a GNUplot script.">GNUplot::PlotVars</a> pv;
<a name="l00720"></a>00720     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a47a2ff80fa9744de494d7f0704899d16" title="template filename (without suffix or path). Directory hard-coded to be &amp;#39;/config&amp;#39;.">inFilename</a>  = <span class="stringliteral">&quot;disagg&quot;</span>;
<a name="l00721"></a>00721     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a52a9c2f3ffc0d107e608d2449657ea50" title="output filename (without suffix or path). Directory = DATA_OUTPUT_PATH config option.">outFilename</a> = <span class="stringliteral">&quot;disagg&quot;</span>;
<a name="l00722"></a>00722     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a1c2d88ef7283190b19c656ccf36d426a" title="Graph title.">title</a>       = <span class="stringliteral">&quot;Automatic disaggregation for &quot;</span> + <a class="code" href="class_power_state_graph.html#ad4518479232495953b076fce87e13201" title="All PowerStateGraphs are associated with a single device.">deviceName</a>;
<a name="l00723"></a>00723     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a259c83d971edf0d273c73b70241385b4">xlabel</a>      = <span class="stringliteral">&quot;time&quot;</span>;
<a name="l00724"></a>00724     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#ab863db5d87f776ce50631876e5f949b0">ylabel</a>      = <span class="stringliteral">&quot;power (kW)&quot;</span>;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="comment">// set sensible xrange, but only if we&#39;re not dealing with synthetic data with a low timecode</span>
<a name="l00727"></a>00727     <span class="keywordflow">if</span> (fingerprintList.front().timestamp &gt; BORDER) {
<a name="l00728"></a>00728         <span class="keyword">const</span> <span class="keywordtype">size_t</span> dstOffset = 3600; <span class="comment">// to correct for BST</span>
<a name="l00729"></a>00729         pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#add27b44d4ed2c2dcd50005a430cc123b" title="Plot arguments (e.g. range). Best not to use this but to put custom args into the template...">plotArgs</a>    = <span class="stringliteral">&quot;[\&quot;&quot;</span> + <a class="code" href="namespace_utils.html#a48dfa27103961c7cc6082f7e68857748">Utils::size_t_to_s</a>( fingerprintList.front().timestamp - BORDER + dstOffset) + <span class="stringliteral">&quot;\&quot;:\&quot;&quot;</span>
<a name="l00730"></a>00730                 + <a class="code" href="namespace_utils.html#a48dfa27103961c7cc6082f7e68857748">Utils::size_t_to_s</a>( fingerprintList.back().timestamp + fingerprintList.back().duration + BORDER + dstOffset) + <span class="stringliteral">&quot;\&quot;]&quot;</span>;
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a9a2dcfdc29af89100641d4f035312aea" title="List of data elements to be plotted.">data</a>.push_back(
<a name="l00734"></a>00734             <a class="code" href="struct_g_n_uplot_1_1_plot_data.html" title="Structure for storing details about data elements to be plotted.">GNUplot::PlotData</a>(
<a name="l00735"></a>00735                     <span class="stringliteral">&quot;disagg&quot;</span>, <span class="stringliteral">&quot;Automatically determined device fingerprint&quot;</span>, <span class="stringliteral">&quot;DISAGG&quot;</span>));
<a name="l00736"></a>00736     pv.<a class="code" href="struct_g_n_uplot_1_1_plot_vars.html#a9a2dcfdc29af89100641d4f035312aea" title="List of data elements to be plotted.">data</a>.push_back(
<a name="l00737"></a>00737             <a class="code" href="struct_g_n_uplot_1_1_plot_data.html" title="Structure for storing details about data elements to be plotted.">GNUplot::PlotData</a>(
<a name="l00738"></a>00738                       aggDataFilename, <span class="stringliteral">&quot;Aggregate data&quot;</span>, <span class="stringliteral">&quot;AGGDATA&quot;</span>, <span class="keyword">false</span>));
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     <a class="code" href="namespace_g_n_uplot.html#ab276a6d946560395f9d6caa8cb6cb640" title="Plot a graph using GNUplot.">GNUplot::plot</a>( pv );
<a name="l00741"></a>00741 }
<a name="l00742"></a>00742 
<a name="l00746"></a><a class="code" href="class_power_state_graph.html#a5ef8ee81761b13f9f16b564aca228994">00746</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a5ef8ee81761b13f9f16b564aca228994">PowerStateGraph::removeOverlapping</a>(
<a name="l00747"></a>00747         list&lt;Fingerprint&gt; * fingerprintList, 
<a name="l00748"></a>00748         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00749"></a>00749         )
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751     list&lt;Fingerprint&gt;::iterator currentDisagItem, prevDisagItem;
<a name="l00752"></a>00752     <span class="keywordtype">size_t</span> count = 0;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754     currentDisagItem = prevDisagItem = fingerprintList-&gt;begin();
<a name="l00755"></a>00755     advance( currentDisagItem, 1 );
<a name="l00756"></a>00756     <span class="keywordflow">while</span> ( currentDisagItem != fingerprintList-&gt;end() ) {
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         <span class="comment">// check to see whether the two disag items overlap</span>
<a name="l00759"></a>00759         <span class="keywordflow">if</span> ( (prevDisagItem-&gt;timestamp + prevDisagItem-&gt;duration) &gt;= currentDisagItem-&gt;timestamp ) {
<a name="l00760"></a>00760 
<a name="l00761"></a>00761             count++;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763             <span class="keywordflow">if</span> (verbose) {
<a name="l00764"></a>00764                 cout &lt;&lt; <span class="stringliteral">&quot;Overlap detected between items with start timestamps &quot;</span>
<a name="l00765"></a>00765                     &lt;&lt; prevDisagItem-&gt;timestamp &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; currentDisagItem-&gt;timestamp &lt;&lt; <span class="stringliteral">&quot; ...&quot;</span>;
<a name="l00766"></a>00766             }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768             <span class="comment">// they overlap.  so find which needs to be replaced</span>
<a name="l00769"></a>00769             <span class="keywordflow">if</span> (prevDisagItem-&gt;avLikelihood &lt; currentDisagItem-&gt;avLikelihood) {
<a name="l00770"></a>00770                 <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;erasing item with timestamp &quot;</span> &lt;&lt; prevDisagItem-&gt;timestamp &lt;&lt; endl;
<a name="l00771"></a>00771                 fingerprintList-&gt;erase( prevDisagItem );
<a name="l00772"></a>00772                 prevDisagItem = currentDisagItem++;
<a name="l00773"></a>00773             } <span class="keywordflow">else</span> {
<a name="l00774"></a>00774                 <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;erasing item with timestamp &quot;</span> &lt;&lt; currentDisagItem-&gt;timestamp &lt;&lt; endl;
<a name="l00775"></a>00775                 fingerprintList-&gt;erase( currentDisagItem++ );
<a name="l00776"></a>00776                 <span class="comment">// don&#39;t change prevDisagItem</span>
<a name="l00777"></a>00777             }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         } <span class="keywordflow">else</span> {
<a name="l00780"></a>00780             prevDisagItem = currentDisagItem++;
<a name="l00781"></a>00781         }
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="keywordflow">if</span> (count == 0) {
<a name="l00785"></a>00785         cout &lt;&lt; <span class="stringliteral">&quot;No candidate fingerprints overlap.&quot;</span> &lt;&lt; endl;
<a name="l00786"></a>00786     } <span class="keywordflow">else</span> {
<a name="l00787"></a>00787         cout &lt;&lt; <span class="stringliteral">&quot;Removed &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot; overlapping candidate fingerprints.&quot;</span> &lt;&lt; endl;
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 
<a name="l00796"></a><a class="code" href="class_power_state_graph.html#a0478f171d51d21613746640c7415fb0b">00796</a> <span class="keyword">const</span> <a class="code" href="struct_power_state_graph_1_1_fingerprint.html">PowerStateGraph::Fingerprint</a> <a class="code" href="class_power_state_graph.html#a0478f171d51d21613746640c7415fb0b">PowerStateGraph::initTraceToEnd</a>(
<a name="l00797"></a>00797         <span class="keyword">const</span> <a class="code" href="struct_aggregate_data_1_1_found_spike.html" title="A simple struct for representing delta spikes found by findSpike()">AggregateData::FoundSpike</a>&amp; spike,
<a name="l00798"></a>00798         <span class="keyword">const</span> <span class="keywordtype">size_t</span> deviceStart, 
<a name="l00799"></a>00799         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00800"></a>00800         )
<a name="l00801"></a>00801 {
<a name="l00802"></a>00802     <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a> disagTree;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     <span class="comment">// make the first vertex (which represents &quot;off&quot;)</span>
<a name="l00805"></a>00805     DisagTree::vertex_descriptor disagOffVertex = add_vertex(disagTree);
<a name="l00806"></a>00806     disagTree[disagOffVertex].timestamp = deviceStart;
<a name="l00807"></a>00807     disagTree[disagOffVertex].meanPower = 0; <span class="comment">// this is &quot;off&quot;</span>
<a name="l00808"></a>00808     disagTree[disagOffVertex].psgVertex = <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="comment">// add a vertex to represent the first true power state</span>
<a name="l00811"></a>00811     DisagTree::vertex_descriptor firstVertex = add_vertex(disagTree);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="comment">// retrieve info for firstVertex and for edge between disagOffVertex and firstVertex</span>
<a name="l00814"></a>00814     <a class="code" href="class_power_state_graph.html#a0076074a11b3c6de4ceeb6bb24714656">PSG_out_edge_iter</a> out_e_i, out_e_end;
<a name="l00815"></a>00815     <a class="code" href="class_power_state_graph.html#ae58789f7684b1f3c2d2dfee295e7e686">PSG_vertex_iter</a> v_i, v_end;
<a name="l00816"></a>00816     tie(out_e_i, out_e_end) = out_edges(<a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a>, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00817"></a>00817     <a class="code" href="struct_power_state_graph_1_1_power_state_edge.html">PowerStateEdge</a> firstEdgeStats = <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*out_e_i];
<a name="l00818"></a>00818     tie(v_i, v_end) = vertices(<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00819"></a>00819     v_i++;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821     disagTree[firstVertex].timestamp = spike.<a class="code" href="struct_aggregate_data_1_1_found_spike.html#abb03eca41172579b649d36849f6b8e79">timestamp</a>;
<a name="l00822"></a>00822     disagTree[firstVertex].meanPower = <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*v_i].betweenSpikes.mean;
<a name="l00823"></a>00823     disagTree[firstVertex].psgVertex = *v_i;
<a name="l00824"></a>00824     disagTree[firstVertex].psgEdge   = *out_e_i;
<a name="l00825"></a>00825     <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a>)
<a name="l00826"></a>00826         disagTree[firstVertex].edgeHistory.push_back(*out_e_i);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828     <span class="comment">// add an edge between disagOffVertex and firstVertex</span>
<a name="l00829"></a>00829     DisagTree::edge_descriptor edge;
<a name="l00830"></a>00830     <span class="keywordtype">bool</span> existingEdge;
<a name="l00831"></a>00831     tie(edge, existingEdge) = add_edge(
<a name="l00832"></a>00832             disagOffVertex,   <span class="comment">// source vertex</span>
<a name="l00833"></a>00833             firstVertex,      <span class="comment">// target vertex</span>
<a name="l00834"></a>00834             spike.<a class="code" href="struct_aggregate_data_1_1_found_spike.html#a7ea84553fc9dd2e1d075391ec7971155">likelihood</a>, <span class="comment">// edge value</span>
<a name="l00835"></a>00835             disagTree);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     <span class="comment">// now recursively trace from this edge to the end</span>
<a name="l00838"></a>00838     <a class="code" href="class_power_state_graph.html#a0df76ca216d2d48aeb44d2bb08046e2f">traceToEnd</a>( &amp;disagTree, firstVertex, deviceStart );
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     <span class="keywordflow">if</span> (verbose) {
<a name="l00841"></a>00841         write_graphviz(cout, disagTree,
<a name="l00842"></a>00842             <a class="code" href="struct_power_state_graph_1_1_disag__vertex__writer.html" title="used for write_graphviz for DisagGraph.">Disag_vertex_writer</a>(disagTree), <a class="code" href="struct_power_state_graph_1_1_disag__edge__writer.html" title="used for write_graphviz for DisagGraph.">Disag_edge_writer</a>(disagTree));
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845     <span class="comment">// find route through the tree with highest average edge likelihoods</span>
<a name="l00846"></a>00846     <a class="code" href="class_power_state_graph.html#a00d8120f4d6c65ba065181df5580e350">listOfPaths</a>.clear();
<a name="l00847"></a>00847 
<a name="l00848"></a>00848     <a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html">LikelihoodAndVertex</a> nextLAV;
<a name="l00849"></a>00849     nextLAV.<a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html#a67f186afad836da5d9c6647a581974be">vertex</a> = firstVertex;
<a name="l00850"></a>00850     nextLAV.<a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html#a6a49a4a69d2b7b78e09d43f16330d91b">likelihood</a> = disagTree[edge];
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <a class="code" href="class_power_state_graph.html#a492bc7278329e94573559ec0cfdd2c7b" title="Trace the tree downwards from vertex recursively finding every path which successfully completes (i...">findListOfPathsThroughDisagTree</a>(
<a name="l00853"></a>00853             disagTree,
<a name="l00854"></a>00854             disagOffVertex,
<a name="l00855"></a>00855             nextLAV);
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     <span class="comment">// Return the most confident path through the disagTree</span>
<a name="l00858"></a>00858     <span class="keywordflow">return</span> <a class="code" href="class_power_state_graph.html#a222bc37f6c90142887eb36b4e31ab568" title="Iterates through each path in listOfPaths to find the one with the highest likelihood.">findBestPath</a>( disagTree, deviceStart );
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00866"></a><a class="code" href="class_power_state_graph.html#a492bc7278329e94573559ec0cfdd2c7b">00866</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a492bc7278329e94573559ec0cfdd2c7b" title="Trace the tree downwards from vertex recursively finding every path which successfully completes (i...">PowerStateGraph::findListOfPathsThroughDisagTree</a>(
<a name="l00867"></a>00867         <span class="keyword">const</span> <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a>&amp; disagTree,
<a name="l00868"></a>00868         <span class="keyword">const</span> DisagTree::vertex_descriptor vertex,
<a name="l00869"></a>00869         <span class="keyword">const</span> <a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html">LikelihoodAndVertex</a> lav,
<a name="l00870"></a>00870         list&lt;PowerStateGraph::LikelihoodAndVertex&gt; path 
<a name="l00871"></a>00871     )
<a name="l00872"></a>00872 {
<a name="l00873"></a>00873     path.push_back( lav );
<a name="l00874"></a>00874 
<a name="l00875"></a>00875     <span class="comment">// base case = we&#39;re at the end</span>
<a name="l00876"></a>00876     <span class="keywordflow">if</span> ( vertex != 0 &amp;&amp; <span class="comment">// check we&#39;re not at the first vertex</span>
<a name="l00877"></a>00877             disagTree[ vertex ].meanPower == 0 ) {
<a name="l00878"></a>00878         <a class="code" href="class_power_state_graph.html#a00d8120f4d6c65ba065181df5580e350">listOfPaths</a>.push_back( path );
<a name="l00879"></a>00879         <span class="keywordflow">return</span>;
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     <span class="comment">// iterate through each out-edge</span>
<a name="l00883"></a>00883     <a class="code" href="class_power_state_graph.html#a03dfe49e81e357744bef48a88d211eb3">Disag_out_edge_iter</a> out_e_i, out_e_end;
<a name="l00884"></a>00884     tie(out_e_i, out_e_end) = out_edges(vertex, disagTree);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="keywordflow">for</span> (; out_e_i!=out_e_end; out_e_i++) {
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         DisagTree::vertex_descriptor downstreamVertex = target(*out_e_i, disagTree);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890         <a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html">LikelihoodAndVertex</a> nextLav;
<a name="l00891"></a>00891         nextLav.<a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html#a67f186afad836da5d9c6647a581974be">vertex</a> = downstreamVertex;
<a name="l00892"></a>00892         nextLav.<a class="code" href="struct_power_state_graph_1_1_likelihood_and_vertex.html#a6a49a4a69d2b7b78e09d43f16330d91b">likelihood</a> = disagTree[*out_e_i];
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="comment">// we haven&#39;t hit the end yet so recursively follow tree downwards.</span>
<a name="l00895"></a>00895         <a class="code" href="class_power_state_graph.html#a492bc7278329e94573559ec0cfdd2c7b" title="Trace the tree downwards from vertex recursively finding every path which successfully completes (i...">findListOfPathsThroughDisagTree</a>(
<a name="l00896"></a>00896                 disagTree,
<a name="l00897"></a>00897                 downstreamVertex,
<a name="l00898"></a>00898                 nextLav,
<a name="l00899"></a>00899                 path );
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     }
<a name="l00902"></a>00902     <span class="keywordflow">return</span>;
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 
<a name="l00909"></a><a class="code" href="class_power_state_graph.html#a0df76ca216d2d48aeb44d2bb08046e2f">00909</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#a0df76ca216d2d48aeb44d2bb08046e2f">PowerStateGraph::traceToEnd</a>(
<a name="l00910"></a>00910         <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a> * disagTree_p, 
<a name="l00911"></a>00911         <span class="keyword">const</span> DisagTree::vertex_descriptor&amp; disagVertex,
<a name="l00912"></a>00912         <span class="keyword">const</span> <span class="keywordtype">size_t</span> prevTimestamp, 
<a name="l00913"></a>00913         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l00914"></a>00914         )<span class="keyword"> const</span>
<a name="l00915"></a>00915 <span class="keyword"></span>{
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;***traceToEnd... prevTimestamp=&quot;</span> &lt;&lt; prevTimestamp &lt;&lt; <span class="stringliteral">&quot; DisagTree startVertex=&quot;</span> &lt;&lt; disagVertex &lt;&lt; endl;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     list&lt;AggregateData::FoundSpike&gt; foundSpikes;
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     <span class="comment">// A handy reference to make the code more readable</span>
<a name="l00922"></a>00922     <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a>&amp; disagTree = *disagTree_p;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="comment">// base case</span>
<a name="l00925"></a>00925     <span class="keywordflow">if</span> ( disagTree[disagVertex].psgVertex == <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a> ) {
<a name="l00926"></a>00926         <span class="keywordflow">return</span>;
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="comment">// For each out-edge from disagVertex.psgVertex, retrieve a list of</span>
<a name="l00930"></a>00930     <span class="comment">// spikes which match and create a new DisagTree vertex for each match.</span>
<a name="l00931"></a>00931     <a class="code" href="class_power_state_graph.html#a0076074a11b3c6de4ceeb6bb24714656">PSG_out_edge_iter</a> psg_out_i, psg_out_end;
<a name="l00932"></a>00932     tie(psg_out_i, psg_out_end) =
<a name="l00933"></a>00933             out_edges(disagTree[disagVertex].psgVertex, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935     <span class="keyword">const</span> <span class="keywordtype">size_t</span> WINDOW_FRAME = 8; <span class="comment">// number of seconds to widen window by</span>
<a name="l00936"></a>00936 
<a name="l00937"></a>00937     <span class="keywordflow">for</span> (; psg_out_i!=psg_out_end; psg_out_i++ ) {
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         <span class="comment">// Commented out alternative strategy for getting edge history. Almost certainly slower than</span>
<a name="l00940"></a>00940         <span class="comment">// using disagTree[disagVertex].edgeHistory</span>
<a name="l00941"></a>00941 <span class="comment">//        std::list&lt; PSGraph::edge_descriptor &gt; eHistory = getEdgeHistoryForVertex(disagTree, disagVertex);</span>
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">if</span> ( ! <a class="code" href="class_power_state_graph.html#a6de44e31afe85bf0ee18dc09a7be329c" title="Check if edge list a and edge list b are equal.">edgeListsAreEqual</a>(
<a name="l00944"></a>00944 <span class="comment">//                eHistory,</span>
<a name="l00945"></a>00945                 disagTree[disagVertex].<a class="code" href="class_power_state_graph.html#abccc8f7ea8259b53926bd149b309686f" title="a &amp;quot;rolling&amp;quot; list storing the previous few edges we&amp;#39;ve seen.">edgeHistory</a>,
<a name="l00946"></a>00946                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].edgeHistory ) ) {
<a name="l00947"></a>00947             <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;edge histories not equal&quot;</span> &lt;&lt; endl;
<a name="l00948"></a>00948             <span class="keywordflow">continue</span>;
<a name="l00949"></a>00949         }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         <span class="keywordtype">size_t</span> begOfSearchWindow, endOfSearchWindow;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="keywordtype">size_t</span> e = <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.nonZeroStdev();
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (verbose)  cout &lt;&lt; <span class="stringliteral">&quot;disagTree[startVertex].timestamp=&quot;</span> &lt;&lt; disagTree[disagVertex].timestamp &lt;&lt; endl;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         begOfSearchWindow = (disagTree[disagVertex].timestamp + <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.min)
<a name="l00958"></a>00958                 - WINDOW_FRAME - e;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960         endOfSearchWindow = (disagTree[disagVertex].timestamp + <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.max)
<a name="l00961"></a>00961                 + WINDOW_FRAME + e;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <span class="comment">//********************** DIAGNOSTICS *************************</span>
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (verbose) {
<a name="l00965"></a>00965             cout &lt;&lt; <span class="stringliteral">&quot;endOfSearchWindow=&quot;</span> &lt;&lt; endOfSearchWindow
<a name="l00966"></a>00966                     &lt;&lt; <span class="stringliteral">&quot; disagTree[startVertex].timestamp=&quot;</span> &lt;&lt; disagTree[disagVertex].timestamp
<a name="l00967"></a>00967                     &lt;&lt; <span class="stringliteral">&quot; powerStateGraph[*psg_out_i].duration.max=&quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.max
<a name="l00968"></a>00968                     &lt;&lt; <span class="stringliteral">&quot; powerStateGraph[*psg_out_i].duration.mean=&quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.mean
<a name="l00969"></a>00969                     &lt;&lt; <span class="stringliteral">&quot; powerStateGraph[*psg_out_i].duration.stdev=&quot;</span> &lt;&lt; <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.stdev
<a name="l00970"></a>00970                     &lt;&lt; endl;
<a name="l00971"></a>00971         }<span class="comment">//__________________________________________________________</span>
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="comment">// ensure we&#39;re not looking backwards in time</span>
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (begOfSearchWindow &lt;= disagTree[disagVertex].timestamp) {
<a name="l00975"></a>00975             begOfSearchWindow =
<a name="l00976"></a>00976                     disagTree[disagVertex].timestamp
<a name="l00977"></a>00977                     + <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.min
<a name="l00978"></a>00978                     - (<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.min / 10);
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="comment">// check that we&#39;re not looking past the end of aggData</span>
<a name="l00982"></a>00982         <span class="keywordflow">if</span> (endOfSearchWindow &gt; (*<a class="code" href="class_power_state_graph.html#a72bfd26474a03ee600df77aada105c75">aggData</a>)[ (*aggData).getSize() - 1 ].timestamp ) {
<a name="l00983"></a>00983             <span class="keywordflow">continue</span>; <span class="comment">// we can&#39;t process this if we&#39;re trying to look past the end of the aggData</span>
<a name="l00984"></a>00984         }
<a name="l00985"></a>00985 
<a name="l00986"></a>00986         <span class="comment">//************************************************************//</span>
<a name="l00987"></a>00987         <span class="comment">// get a list of candidate spikes matching this PSG-out-edge  //</span>
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         foundSpikes.clear();
<a name="l00990"></a>00990         foundSpikes = <a class="code" href="class_power_state_graph.html#a72bfd26474a03ee600df77aada105c75">aggData</a>-&gt;<a class="code" href="class_aggregate_data.html#ada468d155767d721c755405582d108ee" title="Find all spikes in aggregate data which fit spikeStats.">findSpike</a>(
<a name="l00991"></a>00991                 <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].delta,  <span class="comment">// spike stats</span>
<a name="l00992"></a>00992                 begOfSearchWindow,
<a name="l00993"></a>00993                 endOfSearchWindow
<a name="l00994"></a>00994                 );
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         <span class="comment">//***************************************************************//</span>
<a name="l00998"></a>00998         <span class="comment">// for each candidate spike, create a new vertex in disagTree   //</span>
<a name="l00999"></a>00999         <span class="comment">// and recursively trace this to the end                         //</span>
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordflow">for</span> (list&lt;AggregateData::FoundSpike&gt;::const_iterator spike=foundSpikes.begin();
<a name="l01002"></a>01002                 spike!=foundSpikes.end();
<a name="l01003"></a>01003                 spike++) {
<a name="l01004"></a>01004 
<a name="l01005"></a>01005             <span class="comment">// ensure that the absolute value of the aggregate data signal</span>
<a name="l01006"></a>01006             <span class="comment">// does not drop below the minimum for our current power state</span>
<a name="l01007"></a>01007             <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#a72bfd26474a03ee600df77aada105c75">aggData</a>-&gt;<a class="code" href="class_aggregate_data.html#a81a921c732483c6d97cbed3ac1b00366" title="Run through the raw aggregate data from startTime to endTime to make sure that no agg data sample has...">readingGoesBelowPowerState</a>(
<a name="l01008"></a>01008                     disagTree[disagVertex].timestamp,
<a name="l01009"></a>01009                     spike-&gt;timestamp,
<a name="l01010"></a>01010                     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[ disagTree[disagVertex].psgVertex ].betweenSpikes ) ) {
<a name="l01011"></a>01011 
<a name="l01012"></a>01012                 <span class="keywordflow">continue</span>;
<a name="l01013"></a>01013             }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015             <span class="keywordtype">double</span> normalisedLikelihoodForTime = <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*psg_out_i].duration.normalisedLikelihood(
<a name="l01016"></a>01016                     spike-&gt;timestamp - disagTree[disagVertex].timestamp);
<a name="l01017"></a>01017 
<a name="l01018"></a>01018             <span class="comment">// merge probability for time and for spike delta</span>
<a name="l01019"></a>01019             <span class="keywordtype">double</span> avLikelihood = ( normalisedLikelihoodForTime + spike-&gt;likelihood ) / 2;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021             <span class="comment">// create new vertex</span>
<a name="l01022"></a>01022             DisagTree::vertex_descriptor newVertex=add_vertex( disagTree );
<a name="l01023"></a>01023 
<a name="l01024"></a>01024             <span class="comment">// create new edge</span>
<a name="l01025"></a>01025             DisagTree::edge_descriptor newEdge;
<a name="l01026"></a>01026             <span class="keywordtype">bool</span> existingEdge;
<a name="l01027"></a>01027             tie(newEdge, existingEdge) =
<a name="l01028"></a>01028                     add_edge( disagVertex, newVertex, avLikelihood, disagTree );
<a name="l01029"></a>01029 
<a name="l01030"></a>01030             <span class="comment">// add details to newVertex</span>
<a name="l01031"></a>01031             disagTree[newVertex].timestamp = spike-&gt;timestamp;
<a name="l01032"></a>01032             <span class="comment">// get vertex that *psg_out_i points to</span>
<a name="l01033"></a>01033             disagTree[newVertex].psgVertex = target(*psg_out_i, <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l01034"></a>01034             disagTree[newVertex].psgEdge   = *psg_out_i;
<a name="l01035"></a>01035             disagTree[newVertex].meanPower =
<a name="l01036"></a>01036                     <a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[disagTree[newVertex].psgVertex].betweenSpikes.mean;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038             <span class="keywordflow">if</span> (<a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a>) {
<a name="l01039"></a>01039                 disagTree[newVertex].edgeHistory = disagTree[disagVertex].edgeHistory;
<a name="l01040"></a>01040                 disagTree[newVertex].edgeHistory.push_back(*psg_out_i);
<a name="l01041"></a>01041                 <span class="keywordflow">if</span> (disagTree[newVertex].edgeHistory.size() &gt; <a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a>) {
<a name="l01042"></a>01042                     disagTree[newVertex].edgeHistory.erase( disagTree[newVertex].edgeHistory.begin() );
<a name="l01043"></a>01043                 }
<a name="l01044"></a>01044             }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046             <span class="comment">// recursively trace to end.</span>
<a name="l01047"></a>01047             <a class="code" href="class_power_state_graph.html#a0df76ca216d2d48aeb44d2bb08046e2f">traceToEnd</a>(disagTree_p, newVertex, disagTree[disagVertex].timestamp);
<a name="l01048"></a>01048         }
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 }
<a name="l01051"></a>01051 
<a name="l01060"></a><a class="code" href="class_power_state_graph.html#a222bc37f6c90142887eb36b4e31ab568">01060</a> <span class="keyword">const</span> <a class="code" href="struct_power_state_graph_1_1_fingerprint.html">PowerStateGraph::Fingerprint</a> <a class="code" href="class_power_state_graph.html#a222bc37f6c90142887eb36b4e31ab568" title="Iterates through each path in listOfPaths to find the one with the highest likelihood.">PowerStateGraph::findBestPath</a>(
<a name="l01061"></a>01061         <span class="keyword">const</span> <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a>&amp; disagTree,
<a name="l01062"></a>01062         <span class="keyword">const</span> <span class="keywordtype">size_t</span> deviceStart,
<a name="l01063"></a>01063         <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose
<a name="l01064"></a>01064         )
<a name="l01065"></a>01065 {
<a name="l01066"></a>01066     <a class="code" href="struct_power_state_graph_1_1_fingerprint.html">Fingerprint</a> fingerprint;
<a name="l01067"></a>01067     fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#a438d9afe470f8865bf23685e0f0dbeda" title="UNIX timestamp for start time.">timestamp</a> = deviceStart;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069     <span class="comment">// first check that listOfPaths is populated</span>
<a name="l01070"></a>01070     <span class="keywordflow">if</span> ( <a class="code" href="class_power_state_graph.html#a00d8120f4d6c65ba065181df5580e350">listOfPaths</a>.empty() ) {
<a name="l01071"></a>01071         fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> = -1; <span class="comment">// return error code</span>
<a name="l01072"></a>01072         <span class="keywordflow">return</span> fingerprint;
<a name="l01073"></a>01073     }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> = 0;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077     list&lt; list&lt;LikelihoodAndVertex&gt; &gt;::const_iterator path_i, bestPath_i;
<a name="l01078"></a>01078     list&lt; LikelihoodAndVertex &gt;::const_iterator lav_i;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;path dump:&quot;</span> &lt;&lt; endl;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="keywordtype">double</span> likelihoodAccumulator, avLikelihood;
<a name="l01083"></a>01083     <span class="keywordtype">bool</span> foundGoodPath = <span class="keyword">false</span>;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     <span class="comment">// iterate through each path to find the one with the highest likelihood</span>
<a name="l01086"></a>01086     <span class="keywordflow">for</span> (path_i=<a class="code" href="class_power_state_graph.html#a00d8120f4d6c65ba065181df5580e350">listOfPaths</a>.begin(); path_i!=<a class="code" href="class_power_state_graph.html#a00d8120f4d6c65ba065181df5580e350">listOfPaths</a>.end(); path_i++) {
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         likelihoodAccumulator = 0;
<a name="l01089"></a>01089         <span class="keywordflow">for</span> ( lav_i=path_i-&gt;begin(); lav_i!=path_i-&gt;end(); lav_i++ ) {
<a name="l01090"></a>01090             <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;vertex=&quot;</span> &lt;&lt; lav_i-&gt;vertex &lt;&lt; <span class="stringliteral">&quot; conf=&quot;</span> &lt;&lt; lav_i-&gt;likelihood &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l01091"></a>01091             likelihoodAccumulator += lav_i-&gt;likelihood;
<a name="l01092"></a>01092         }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094         avLikelihood = likelihoodAccumulator / path_i-&gt;size();
<a name="l01095"></a>01095 
<a name="l01096"></a>01096         <span class="comment">// if this is the most confident path we&#39;ve seen yet then record its details.</span>
<a name="l01097"></a>01097         <span class="keywordflow">if</span> ( avLikelihood &gt;= fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> ) {
<a name="l01098"></a>01098             fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> = avLikelihood;
<a name="l01099"></a>01099             bestPath_i = path_i;
<a name="l01100"></a>01100             foundGoodPath = <span class="keyword">true</span>;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">if</span> (verbose) cout &lt;&lt; endl &lt;&lt; endl;
<a name="l01104"></a>01104     }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="comment">// now get energy usage and duration from bestPath_i</span>
<a name="l01107"></a>01107     <span class="keywordtype">size_t</span> prevTimestamp, duration;
<a name="l01108"></a>01108     <span class="keywordtype">double</span> prevMeanPower = 0;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110     fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#a76d36700804fc3557e73729b03faadfb" title="energy consumed (Joules)">energy</a> = 0;
<a name="l01111"></a>01111     fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ab573e3a2e9143f0139782072f8938ecb" title="Duration (in seconds)">duration</a> = 0;
<a name="l01112"></a>01112     duration = 0;
<a name="l01113"></a>01113     prevTimestamp = deviceStart;
<a name="l01114"></a>01114     <span class="keywordtype">size_t</span> count = 0;
<a name="l01115"></a>01115     <span class="keywordflow">if</span> (foundGoodPath) {
<a name="l01116"></a>01116         <span class="keywordflow">for</span> (lav_i=bestPath_i-&gt;begin(); lav_i != bestPath_i-&gt;end(); lav_i++) {
<a name="l01117"></a>01117 
<a name="l01118"></a>01118             <span class="comment">// Add to timeAndPower list for read-out later when we plot the power states</span>
<a name="l01119"></a>01119             <span class="keywordflow">if</span> ( lav_i != bestPath_i-&gt;begin() ) {
<a name="l01120"></a>01120                 fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#aacb278eafcf7236a8487196b50c835aa">timeAndPower</a>.push_back( <a class="code" href="struct_power_state_graph_1_1_time_and_power.html" title="A simple struct for pairing timestamp and meanPower. Used in Fingerprint struct.">TimeAndPower</a>(
<a name="l01121"></a>01121                         disagTree[ lav_i-&gt;vertex ].timestamp-1 ,
<a name="l01122"></a>01122                         (count==1 ? 0 : prevMeanPower)
<a name="l01123"></a>01123                 ) );
<a name="l01124"></a>01124                 fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#aacb278eafcf7236a8487196b50c835aa">timeAndPower</a>.push_back( <a class="code" href="struct_power_state_graph_1_1_time_and_power.html" title="A simple struct for pairing timestamp and meanPower. Used in Fingerprint struct.">TimeAndPower</a>(
<a name="l01125"></a>01125                         disagTree[ lav_i-&gt;vertex ].timestamp,
<a name="l01126"></a>01126                         disagTree[ lav_i-&gt;vertex ].meanPower) );
<a name="l01127"></a>01127             }
<a name="l01128"></a>01128 
<a name="l01129"></a>01129             <span class="comment">// Now calculate duration and energy consumption</span>
<a name="l01130"></a>01130             duration = disagTree[ lav_i-&gt;vertex ].timestamp - prevTimestamp;
<a name="l01131"></a>01131             fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#a76d36700804fc3557e73729b03faadfb" title="energy consumed (Joules)">energy</a> += prevMeanPower * duration;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133             fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ab573e3a2e9143f0139782072f8938ecb" title="Duration (in seconds)">duration</a> += duration;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135             prevTimestamp = disagTree[ lav_i-&gt;vertex ].timestamp;
<a name="l01136"></a>01136             prevMeanPower = disagTree[ lav_i-&gt;vertex ].meanPower;
<a name="l01137"></a>01137             count++;
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> = ( fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> +
<a name="l01141"></a>01141                 <a class="code" href="class_power_state_graph.html#acd3ccedf90895a1c82e4b6c5b4e53300" title="Energy consumption in Joules obtained from training signatures.">energyConsumption</a>.<a class="code" href="struct_statistic.html#a16764e35873ab9b1cfbffe5668515b47" title="The likelihood is normalised by dividing the raw likelihood by the likelihood of the distribution&amp;#39...">normalisedLikelihood</a>(fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#a76d36700804fc3557e73729b03faadfb" title="energy consumed (Joules)">energy</a>) ) / 2;
<a name="l01142"></a>01142     } <span class="keywordflow">else</span> {
<a name="l01143"></a>01143         fingerprint.<a class="code" href="struct_power_state_graph_1_1_fingerprint.html#ac3d6a362a66f0406a4716e4a07405e23" title="Average likelihood.">avLikelihood</a> = -1;
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     <span class="keywordflow">return</span> fingerprint;
<a name="l01147"></a>01147 }
<a name="l01148"></a>01148 
<a name="l01152"></a><a class="code" href="class_power_state_graph.html#a02f0ffcb7632abbf717ea43e79469193">01152</a> list&lt; PowerStateGraph::PSGraph::edge_descriptor &gt; <a class="code" href="class_power_state_graph.html#a02f0ffcb7632abbf717ea43e79469193" title="Trace the disagTree backwards.">PowerStateGraph::getEdgeHistoryForVertex</a>(
<a name="l01153"></a>01153         <span class="keyword">const</span> <a class="code" href="class_power_state_graph.html#a2be617d73dc54598aacb7b7a2970c015" title="Tree structure used to keep track of all the possible solutions during disaggregation.">DisagTree</a>&amp; disagTree,
<a name="l01154"></a>01154         <span class="keyword">const</span> DisagTree::vertex_descriptor&amp; startVertex
<a name="l01155"></a>01155         )<span class="keyword"> const</span>
<a name="l01156"></a>01156 <span class="keyword"></span>{
<a name="l01157"></a>01157     list&lt; PSGraph::edge_descriptor &gt; eHistory;
<a name="l01158"></a>01158     DisagTree::vertex_descriptor disagVertex = startVertex;
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     DisagTree::in_edge_iterator in_e_i, in_e_end;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="keywordflow">while</span> (disagTree[disagVertex].psgVertex != <a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a> &amp;&amp; eHistory.size() &lt; <a class="code" href="class_power_state_graph.html#aba24b63b53d87e8a1d6cc5667a1c7254" title="Set to 0 to disable.">EDGE_HISTORY_SIZE</a>) {
<a name="l01163"></a>01163         eHistory.push_front( disagTree[disagVertex].psgEdge );
<a name="l01164"></a>01164         tie(in_e_i, in_e_end) = in_edges(disagVertex, disagTree);
<a name="l01165"></a>01165         disagVertex = source( *in_e_i, disagTree ); <span class="comment">// the vertex upstream from in_e_i</span>
<a name="l01166"></a>01166     }
<a name="l01167"></a>01167 
<a name="l01168"></a>01168     <span class="keywordflow">return</span> eHistory;
<a name="l01169"></a>01169 }
<a name="l01170"></a>01170 
<a name="l01171"></a><a class="code" href="class_power_state_graph.html#ad077e00b7ecda2cdf2acb79201cbd6aa">01171</a> <span class="keywordtype">void</span> <a class="code" href="class_power_state_graph.html#ad077e00b7ecda2cdf2acb79201cbd6aa">PowerStateGraph::setDeviceName</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; _deviceName)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173     <a class="code" href="class_power_state_graph.html#ad4518479232495953b076fce87e13201" title="All PowerStateGraphs are associated with a single device.">deviceName</a> = _deviceName;
<a name="l01174"></a>01174 }
<a name="l01175"></a>01175 
<a name="l01176"></a><a class="code" href="_power_state_graph_8cpp.html#a8c2cd09d96e09cba0e51a0bf5b1fdc57">01176</a> std::ostream&amp; <a class="code" href="class_power_state_graph.html#a8c2cd09d96e09cba0e51a0bf5b1fdc57">operator&lt;&lt;</a>( std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="class_power_state_graph.html" title="This class does most of the work behind the &amp;quot;graphs and spikes&amp;quot; disaggregation approach...">PowerStateGraph</a>&amp; psg )
<a name="l01177"></a>01177 {
<a name="l01178"></a>01178     <a class="code" href="class_power_state_graph.html#a9086743593caa95a9bdcc5246ac729a2">PowerStateGraph::PSG_vertex_index_map</a> index = boost::get(boost::vertex_index, psg.<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180     o &lt;&lt; <span class="stringliteral">&quot;vertices(graph) = &quot;</span> &lt;&lt; std::endl;
<a name="l01181"></a>01181     std::pair&lt;PowerStateGraph::PSG_vertex_iter, PowerStateGraph::PSG_vertex_iter&gt; vp;
<a name="l01182"></a>01182     <span class="keywordflow">for</span> (vp = boost::vertices(psg.<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>); vp.first != vp.second; ++vp.first) {
<a name="l01183"></a>01183         o &lt;&lt; <span class="stringliteral">&quot;vertex&quot;</span> &lt;&lt; index[*vp.first] &lt;&lt; <span class="stringliteral">&quot; = {&quot;</span> &lt;&lt; psg.<a class="code" href="class_power_state_graph.html#a668ed95d7ae27ad400c80d5c691e10e8" title="store the power state graph learnt during training.">powerStateGraph</a>[*vp.first].postSpike &lt;&lt;  <span class="stringliteral">&quot;}&quot;</span>;
<a name="l01184"></a>01184         <span class="keywordflow">if</span> ( *vp.first == psg.<a class="code" href="class_power_state_graph.html#a0ce0845fa70aa3ec29aee1f0c78de54e">offVertex</a> ) {
<a name="l01185"></a>01185             o &lt;&lt; <span class="stringliteral">&quot;\n          (offVertex)&quot;</span> &lt;&lt; std::endl;
<a name="l01186"></a>01186         }
<a name="l01187"></a>01187         o &lt;&lt; std::endl;
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189 
<a name="l01190"></a>01190     <span class="keywordflow">return</span> o;
<a name="l01191"></a>01191 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_power_state_graph_8cpp.html">PowerStateGraph.cpp</a>      </li>
      <li class="footer">Generated on Fri Sep 9 2011 17:06:35 for Disaggregate by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
